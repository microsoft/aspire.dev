---
interface Option {
    id: string;
    title: string;
    disabled?: boolean;
}

type Props = {
    options: Option[];
    key: string;
    title?: string;
};

const { options, key, title } = Astro.props;
---

<div class="pivot-container not-content">
    {title && <div class="pivot-title">{title}</div>}
    <div class="pivot-selector" id=`pivot-selector-${key}`>
        {
            options.map((o) => (
                <button
                    type="button"
                    data-pivot-option={o.id}
                    disabled={o.disabled ? true : false}
                >
                    {o.title}
                </button>
            ))
        }
    </div>
</div>

<style>
    .pivot-container {
        background: var(--sl-color-bg-nav);
        border: 1px solid var(--sl-color-gray-5);
        border-radius: 0.5rem;
        padding: 1rem;
        box-shadow: var(--sl-shadow-sm);
        margin-bottom: 1.5rem;
        --pivot-float-x: -50%;
    }

    /* Floating state */
    .pivot-container.floating {
        position: fixed;
        top: calc(var(--sl-nav-height) + 0.35rem);
        left: 50%;
        transform: translateX(-50%);
        z-index: var(--sl-z-index-toc, 10);
        box-shadow: var(--sl-shadow-md);
        border-color: var(--sl-color-gray-4);
        max-width: min(calc(100vw - 2rem), 800px);
        width: auto;
        opacity: 1;
        animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);

        .pivot-title {
            display: none;
        }
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateX(var(--pivot-float-x)) translateY(-2rem);
        }
        to {
            opacity: 1;
            transform: translateX(var(--pivot-float-x)) translateY(0);
        }
    }

    /* Placeholder to prevent layout shift */
    .pivot-container.floating + .pivot-placeholder {
        display: block;
    }

    .pivot-placeholder {
        display: none;
    }

    .pivot-title {
        color: var(--aspire-color-secondary);
        font-size: var(--sl-text-lg);
        margin-bottom: 0.75rem;
    }

    .pivot-selector {
        display: inline-flex;
        justify-content: space-between;
        background: var(--sl-color-bg);
        border: 1px solid var(--sl-color-gray-4);
        border-radius: 0.5rem;
        padding: 0.25rem;
        gap: 0.25rem;
        color: var(--sl-color-text);
    }

    .floating .pivot-selector {
        display: flex;
        justify-content: space-between;
    }

    .pivot-selector button {
        padding: 0.25rem 1rem;
        border: none;
        background: transparent;
        color: var(--sl-color-text);
        border-radius: 0.5rem;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        margin-top: 0;
        min-width: 4rem;
    }

    @media (max-width: 72rem) {
        .pivot-container {
            --pivot-float-x: 0;
        }

        /* Adjust floating position when mobile TOC is visible */
        .pivot-container.floating {
            top: calc(
                var(--sl-nav-height, 0px) + var(--sl-mobile-toc-height, 0px)
            );
            left: var(--sl-sidebar-width);
            right: 0;
            max-width: 100%;
            border-radius: 0;
            border-left: none;
            border-right: none;
            border-top: none;
            padding: 0.5rem 1rem;
            margin: 0;
            transform: translateX(0);
        }

        .pivot-container.floating .pivot-title {
            display: none;
        }

        .pivot-container.floating .pivot-selector {
            display: inline-flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 0.5rem;
            padding: 0.125rem;
        }

        .pivot-container.floating .pivot-selector button {
            padding: 0.25rem 0.5rem;
            font-size: var(--sl-text-xs);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    }

    @media (max-width: 48rem) {
        .pivot-container.floating {
            top: calc(
                var(--sl-nav-height, 0px) + var(--sl-mobile-toc-height, 0px)
            );
            left: 0;
            right: 0;
            max-width: 100%;
            border-radius: 0;
            border-left: none;
            border-right: none;
            border-top: none;
            padding: 0.5rem 1rem;
            margin: 0;
            transform: translateX(0);
        }

        /* Non-floating mobile: stacked layout */
        .pivot-selector {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .pivot-selector button {
            text-align: center;
        }
    }

    .pivot-selector button:hover {
        background: var(--sl-color-gray-4);
        color: var(--sl-color-white);
    }

    .pivot-selector button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .pivot-selector button.active {
        background: var(--aspire-color-secondary);
        border: 1px solid var(--sl-color-gray-5);
        color: var(--sl-color-black);
    }

    .pivot-selector button:focus-visible {
        outline: 2px solid var(--sl-color-accent);
        outline-offset: 2px;
    }

    :root[data-theme="light"] {
        .pivot-title {
            color: var(--sl-color-text);
        }
        .pivot-selector button.active {
            background: var(--aspire-color-primary);
        }
    }
</style>

<script is:inline define:vars={{ key }}>
    function initPivotSelector() {
        const qsKey = key;
        const selector = document.getElementById(`pivot-selector-${key}`);

        if (!selector) {
            console.warn("Pivot selector not found!");
            return;
        }

        const container = selector.closest(".pivot-container");
        if (!container) {
            console.warn("Pivot container not found!");
            return;
        }

        // Get all valid (non-disabled) options
        const validButtons = [
            ...selector.querySelectorAll("button:not(:disabled)"),
        ];
        const validOptions = validButtons.map((btn) => btn.dataset.pivotOption);

        // Read from query string -> storage -> first valid option
        const qs = new URLSearchParams(window.location.search);
        const qsValue = qs.get(qsKey);
        const storageValue = localStorage.getItem(qsKey);
        const firstValid = validButtons[0]?.dataset.pivotOption;

        // Validate and use the first valid value
        let current =
            qsValue && validOptions.includes(qsValue)
                ? qsValue
                : storageValue && validOptions.includes(storageValue)
                  ? storageValue
                  : firstValid;

        function findNearestVisibleHeading() {
            // Find all headings in the main content area
            const headings = document.querySelectorAll(
                "main h1, main h2, main h3, main h4, main h5, main h6",
            );

            if (headings.length === 0) return null;

            const scrollTop =
                window.pageYOffset || document.documentElement.scrollTop;
            const viewportTop = scrollTop;

            // Find the nearest heading above or at the current scroll position
            let nearestHeading = null;
            let minDistance = Infinity;

            for (const heading of headings) {
                // Skip headings that are hidden
                if (heading.offsetParent === null) continue;

                const rect = heading.getBoundingClientRect();
                const headingTop = scrollTop + rect.top;
                const distance = viewportTop - headingTop;

                // We want headings that are above the viewport (distance >= 0)
                // or just slightly below (within reasonable threshold)
                if (distance >= -100 && distance < minDistance) {
                    minDistance = distance;
                    nearestHeading = heading;
                }
            }

            if (!nearestHeading) return null;

            const rect = nearestHeading.getBoundingClientRect();
            return {
                id: nearestHeading.id,
                text: nearestHeading.textContent,
                offset: rect.top, // Distance from top of viewport
            };
        }

        function restoreScrollPosition(anchor) {
            if (!anchor) return;

            // Try to find the heading by ID first, then by text content
            let targetHeading = null;

            if (anchor.id) {
                targetHeading = document.getElementById(anchor.id);
            }

            if (!targetHeading && anchor.text) {
                const headings = document.querySelectorAll(
                    "main h1, main h2, main h3, main h4, main h5, main h6",
                );
                for (const heading of headings) {
                    if (
                        heading.offsetParent !== null &&
                        heading.textContent === anchor.text
                    ) {
                        targetHeading = heading;
                        break;
                    }
                }
            }

            if (targetHeading) {
                // Calculate the scroll position to maintain the same offset
                const rect = targetHeading.getBoundingClientRect();
                const scrollTop =
                    window.pageYOffset || document.documentElement.scrollTop;
                const targetScrollTop = scrollTop + rect.top - anchor.offset;

                // Use smooth scroll for better UX
                window.scrollTo({
                    top: targetScrollTop,
                    behavior: "instant", // Use 'instant' to avoid jarring effect
                });
            }
        }

        function apply(id) {
            if (!id) return;

            // Only apply if it's a valid, non-disabled option
            if (!validOptions.includes(id)) {
                console.warn(`Invalid pivot option: ${id}`);
                return;
            }

            // Capture scroll position anchor before changing content
            const scrollAnchor = findNearestVisibleHeading();

            current = id;

            // persist pref
            localStorage.setItem(qsKey, id);

            // sync URL
            const url = new URL(window.location);
            url.searchParams.set(qsKey, id);
            window.history.replaceState({}, "", url);

            // style buttons
            [...selector.querySelectorAll("button")].forEach((btn) =>
                btn.classList.toggle("active", btn.dataset.pivotOption === id),
            );

            // show/hide pivot blocks
            const blocks = document.querySelectorAll("[data-pivot-block]");
            blocks.forEach((el) => {
                const blockId = el.dataset.pivotBlock;
                // Support multiple IDs separated by comma or semicolon
                const blockIds = blockId.split(/[,;]/).map(id => id.trim());
                const shouldShow = blockIds.includes(id);
                el.style.display = shouldShow ? "" : "none";
            });

            // Restore scroll position after content change
            // Use requestAnimationFrame to ensure the new content has been rendered
            requestAnimationFrame(() => {
                restoreScrollPosition(scrollAnchor);
            });
        }

        selector.addEventListener("click", (e) => {
            if (e.target.dataset.pivotOption) {
                apply(e.target.dataset.pivotOption);
            }
        });

        apply(current);

        // Floating behavior
        let placeholder = null;
        let originalTop = 0;
        let isFloating = false;
        let ticking = false;

        function createPlaceholder() {
            if (!placeholder) {
                placeholder = document.createElement("div");
                placeholder.className = "pivot-placeholder";
                container.parentNode.insertBefore(
                    placeholder,
                    container.nextSibling,
                );
            }
            const rect = container.getBoundingClientRect();
            placeholder.style.height = `${rect.height}px`;
            placeholder.style.marginBottom =
                getComputedStyle(container).marginBottom;
        }

        function updateFloatingState() {
            const rect = container.getBoundingClientRect();
            const scrollTop =
                window.pageYOffset || document.documentElement.scrollTop;

            // Calculate the original position (only once or when not floating)
            if (!isFloating) {
                originalTop = scrollTop + rect.top;
            }

            const shouldFloat = scrollTop > originalTop;

            if (shouldFloat !== isFloating) {
                isFloating = shouldFloat;

                if (isFloating) {
                    createPlaceholder();
                    container.classList.add("floating");
                } else {
                    container.classList.remove("floating");
                    if (placeholder) {
                        placeholder.style.height = "0px";
                    }
                }
            }

            ticking = false;
        }

        function onScroll() {
            if (!ticking) {
                window.requestAnimationFrame(updateFloatingState);
                ticking = true;
            }
        }

        // Initialize floating behavior
        function initFloating() {
            // Delay to ensure layout is settled
            setTimeout(() => {
                const rect = container.getBoundingClientRect();
                const scrollTop =
                    window.pageYOffset || document.documentElement.scrollTop;
                originalTop = scrollTop + rect.top;

                window.addEventListener("scroll", onScroll, { passive: true });

                // Check initial state (e.g., if user deep-linked and page loaded scrolled)
                updateFloatingState();
            }, 100);
        }

        // Handle resize - recalculate positions
        let resizeTimeout;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (!isFloating) {
                    const rect = container.getBoundingClientRect();
                    const scrollTop =
                        window.pageYOffset ||
                        document.documentElement.scrollTop;
                    originalTop = scrollTop + rect.top;
                }
                updateFloatingState();
            }, 150);
        });

        initFloating();
    }

    // Run when DOM is ready
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initPivotSelector);
    } else {
        initPivotSelector();
    }
</script>
