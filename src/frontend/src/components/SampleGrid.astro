---
import SampleCard from '@components/SampleCard.astro';
import { tagLabel } from '@utils/sample-tags';

interface Sample {
  name: string;
  title: string;
  description: string | null;
  href: string;
  readme: string;
  tags: string[];
  thumbnail: string | null;
}

interface Props {
  samples: Sample[];
}

const { samples } = Astro.props;

// Eagerly import all sample images at build time
const allImages = import.meta.glob<{ default: ImageMetadata }>(
  '/src/assets/samples/**/*.{png,jpg,jpeg,gif,svg,webp}',
  { eager: true }
);

// Build a lookup from the ~/assets/... path to the resolved image
function resolveImage(thumbnail: string | null): ImageMetadata | null {
  if (!thumbnail) return null;
  // Convert ~/assets/samples/... to /src/assets/samples/...
  const importPath = thumbnail.replace('~/assets/', '/src/assets/');
  const entry = allImages[importPath];
  return entry?.default ?? null;
}

const resolvedSamples = samples.map((s) => ({
  ...s,
  resolvedThumbnail: resolveImage(s.thumbnail),
}));

// Collect all unique tags, sorted alphabetically
const allTags = [...new Set(samples.flatMap((s) => s.tags))].sort();


---

<div class="samples-browser not-content" data-samples-browser>
  <!-- Search and filter bar -->
  <div class="controls">
    <div class="search-container">
      <svg
        class="search-icon"
        aria-hidden="true"
        width="16"
        height="16"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
      <input
        autocomplete="off"
        spellcheck="false"
        type="text"
        class="search-box"
        placeholder="Search samples..."
        data-search-input
      />
      <button class="clear-button" aria-label="Clear search" type="button" data-clear-btn>
        Clear
      </button>
    </div>

    <div class="tag-filters" data-tag-filters>
      {allTags.map((tag) => (
        <button
          class="tag-chip"
          data-tag={tag}
          type="button"
          aria-pressed="false"
        >
          {tagLabel(tag)}
        </button>
      ))}
    </div>
  </div>

  <!-- Results count -->
  <div class="results-bar">
    <span class="results-count" data-results-count>
      {samples.length} {samples.length === 1 ? 'sample' : 'samples'}
    </span>
    <button class="clear-filters" data-clear-filters type="button" style="display: none;">
      Clear filters
    </button>
  </div>

  <!-- Card grid -->
  <div class="card-grid" data-card-grid>
    {resolvedSamples.map((sample) => (
      <div class="card-item" data-sample-item>
        <SampleCard sample={sample} />
      </div>
    ))}
  </div>

  <!-- Empty state -->
  <div class="empty-state" data-empty-state style="display: none;">
    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      <line x1="8" y1="11" x2="14" y2="11"></line>
    </svg>
    <p>No samples match your filters.</p>
    <button class="reset-btn" data-reset-btn type="button">Reset all filters</button>
  </div>
</div>

<!-- is:inline is required so the filter/search logic runs synchronously in the
     page rather than being bundled and deferred by Astro's script processing.
     This ensures the grid is interactive immediately on page load. -->
<script is:inline>
  (function () {
    const browser = document.querySelector('[data-samples-browser]');
    if (!browser) return;

    const searchInput = browser.querySelector('[data-search-input]');
    const clearBtn = browser.querySelector('[data-clear-btn]');
    const tagChips = browser.querySelectorAll('[data-tag]');
    const cardGrid = browser.querySelector('[data-card-grid]');
    const cardItems = browser.querySelectorAll('[data-sample-item]');
    const resultsCount = browser.querySelector('[data-results-count]');
    const clearFilters = browser.querySelector('[data-clear-filters]');
    const emptyState = browser.querySelector('[data-empty-state]');
    const resetBtn = browser.querySelector('[data-reset-btn]');

    let activeTags = new Set();
    let searchQuery = '';

    function applyFilters() {
      let visible = 0;
      const query = searchQuery.toLowerCase().trim();

      cardItems.forEach((item) => {
        const card = item.querySelector('.sample-card');
        if (!card) return;

        const title = card.dataset.title || '';
        const name = card.dataset.name || '';
        const desc = card.dataset.description || '';
        const tags = (card.dataset.tags || '').split(',').filter(Boolean);

        // Text search
        let matchesSearch = true;
        if (query) {
          matchesSearch =
            title.includes(query) ||
            name.includes(query) ||
            desc.includes(query) ||
            tags.some((t) => t.includes(query));
        }

        // Tag filter (AND logic)
        let matchesTags = true;
        if (activeTags.size > 0) {
          matchesTags = [...activeTags].every((tag) => tags.includes(tag));
        }

        if (matchesSearch && matchesTags) {
          item.style.display = '';
          visible++;
        } else {
          item.style.display = 'none';
        }
      });

      // Update count
      resultsCount.textContent = `${visible} ${visible === 1 ? 'sample' : 'samples'}`;

      // Toggle empty state
      const hasFilters = query || activeTags.size > 0;
      cardGrid.style.display = visible === 0 ? 'none' : '';
      emptyState.style.display = visible === 0 ? '' : 'none';
      clearFilters.style.display = hasFilters ? '' : 'none';
      clearBtn.style.display = query ? '' : 'none';
    }

    // Search
    searchInput.addEventListener('input', (e) => {
      searchQuery = e.target.value;
      applyFilters();
    });

    clearBtn.addEventListener('click', () => {
      searchInput.value = '';
      searchQuery = '';
      applyFilters();
      searchInput.focus();
    });

    // Tag chips
    tagChips.forEach((chip) => {
      chip.addEventListener('click', () => {
        const tag = chip.dataset.tag;
        if (activeTags.has(tag)) {
          activeTags.delete(tag);
          chip.classList.remove('active');
          chip.setAttribute('aria-pressed', 'false');
        } else {
          activeTags.add(tag);
          chip.classList.add('active');
          chip.setAttribute('aria-pressed', 'true');
        }
        applyFilters();
      });
    });

    // Clear all
    function resetAll() {
      searchInput.value = '';
      searchQuery = '';
      activeTags.clear();
      tagChips.forEach((chip) => {
        chip.classList.remove('active');
        chip.setAttribute('aria-pressed', 'false');
      });
      applyFilters();
    }

    clearFilters.addEventListener('click', resetAll);
    if (resetBtn) resetBtn.addEventListener('click', resetAll);

    // Initialize
    clearBtn.style.display = 'none';
    applyFilters();
  })();
</script>

<style>
  .samples-browser {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  /* ---- Controls ---- */
  .controls {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .search-container {
    position: relative;
    display: flex;
    align-items: center;
    width: 100%;
  }

  .search-icon {
    position: absolute;
    left: 0.75rem;
    color: var(--sl-color-gray-3);
    pointer-events: none;
  }

  .search-box {
    width: 100%;
    padding: 0.625rem 4.5rem 0.625rem 2.25rem;
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 0.5rem;
    background: var(--sl-color-gray-6);
    color: var(--sl-color-white);
    font-size: 0.95rem;
    outline: none;
    transition: border-color 0.2s;
  }

  .search-box::placeholder {
    color: var(--sl-color-gray-3);
  }

  .search-box:focus {
    border-color: var(--sl-color-accent);
  }

  .clear-button {
    position: absolute;
    right: 0.5rem;
    background: var(--sl-color-gray-5);
    border: none;
    border-radius: 0.25rem;
    color: var(--sl-color-white);
    padding: 0.25rem 0.5rem;
    font-size: 0.8rem;
    cursor: pointer;
    display: none;
  }

  .clear-button:hover {
    background: var(--sl-color-gray-4);
  }

  /* ---- Tag Filters ---- */
  .tag-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.375rem;
  }

  .tag-chip {
    padding: 0.3rem 0.65rem;
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 2rem;
    background: var(--sl-color-gray-6);
    color: var(--sl-color-gray-2);
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.15s ease;
    white-space: nowrap;
  }

  .tag-chip:hover {
    border-color: var(--sl-color-gray-3);
    color: var(--sl-color-white);
  }

  .tag-chip.active {
    background: var(--sl-color-accent);
    border-color: var(--sl-color-accent);
    color: var(--sl-color-accent-high);
    font-weight: 600;
  }

  /* ---- Results Bar ---- */
  .results-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
  }

  .results-count {
    font-size: 0.875rem;
    color: var(--sl-color-gray-2);
    font-weight: 500;
  }

  .clear-filters {
    background: none;
    border: none;
    color: var(--sl-color-accent-high);
    font-size: 0.85rem;
    cursor: pointer;
    padding: 0;
    text-decoration: underline;
  }

  .clear-filters:hover {
    color: var(--sl-color-white);
  }

  /* ---- Card Grid (CSS columns for masonry) ---- */
  .card-grid {
    column-count: 1;
    column-gap: 1.25rem;
  }

  @media (min-width: 768px) {
    .card-grid {
      column-count: 2;
    }
  }

  .card-item {
    break-inside: avoid;
    margin-bottom: 1.25rem;
  }

  /* ---- Empty State ---- */
  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    padding: 3rem 1rem;
    color: var(--sl-color-gray-3);
    text-align: center;
  }

  .empty-state p {
    margin: 0;
    font-size: 1.1rem;
  }

  .reset-btn {
    background: var(--sl-color-accent);
    border: none;
    border-radius: 0.5rem;
    color: var(--sl-color-accent-high);
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .reset-btn:hover {
    opacity: 0.85;
  }
</style>
