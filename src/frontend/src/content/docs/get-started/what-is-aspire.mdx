---
title: What is Aspire?
description: Learn how Aspire simplifies the development, deployment, and debugging of distributed applications.
tableOfContents: true
lastUpdated: true
---

import { Aside, Steps } from '@astrojs/starlight/components';
import LearnMore from '@components/LearnMore.astro';

Aspire streamlines building, running, debugging, and deploying distributed apps. Picture your app as a set of services, databases, and frontends‚Äîwhen they're deployed, they all work together seamlessly, but every time you develop them they need to be individually started and connected. With Aspire, you get a unified toolchain that eliminates complex configs and makes local debugging effortless. Instantly launch and debug your entire app with a single command. Ready to deploy? Aspire lets you publish anywhere‚ÄîKubernetes, the cloud, or your own servers. It's also fully extensible, so you can integrate your favorite tools and services with ease.

## Why Aspire?

Building modern applications means juggling multiple services, databases, and dependencies. Here's what that looks like **without** Aspire:

### The pain of distributed development

| Problem | Without Aspire | With Aspire |
|---------|----------------|-------------|
| **Starting services** | Open 5 terminals, run 5 different commands, hope they start in the right order | Run `aspire run` ‚Äî everything starts automatically. See [AppHost overview](/get-started/app-host/). |
| **Connection strings** | Hardcode `localhost:5432` everywhere, break production deploys | Service discovery handles it ‚Äî same code works locally and in production. See [Service discovery](/fundamentals/service-discovery/). |
| **"Works on my machine"** | Different team members have different ports, different configs | One AppHost definition, everyone runs the same setup. See [First app tutorial](/get-started/first-app/). |
| **Debugging** | Attach debugger to each service individually | Debug your entire stack with a single F5. See [Debugging overview](/fundamentals/debugging/). |
| **Finding logs** | Check 5 different terminal windows | Aspire Dashboard shows all logs in one place. See [Dashboard overview](/dashboard/overview/). |
| **Adding a database** | Install locally, configure connection, hope versions match | `builder.AddPostgres("db")` ‚Äî containerized, versioned, consistent. See [Integrations](/integrations/overview/). |

### Before and after

**Without Aspire**, your startup routine might look like:

<Steps>

1. Start the database container

   ```bash frame="terminal" data-disable-copy
   docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=secret postgres:15
   ```

2. Start the C# API service

   ```bash frame="terminal" data-disable-copy
   cd api && dotnet run
   ```

3. Start the Python worker

   ```bash frame="terminal" data-disable-copy
   cd worker && source .venv/bin/activate && python main.py
   ```

4. Start the JavaScript frontend

   ```bash frame="terminal" data-disable-copy
   cd frontend && npm run dev
   ```

5. Manually verify they can all connect...

   Frustration ensues. üôÅ

</Steps>

**With Aspire**, it's just:

```bash
aspire run
```

And your AppHost defines everything in type-safe C#‚Äîeven for polyglot stacks:

```csharp title="AppHost.cs"
var builder = DistributedApplication.CreateBuilder(args);

var db = builder.AddPostgres("db");

var api = builder.AddProject<Projects.Api>("api")
    .WithReference(db);

var worker = builder.AddPythonApp("worker", "../worker", "main.py")
    .WithReference(db);

builder.AddNpmApp("frontend", "../frontend")
    .WithReference(api);

builder.Build().Run();
```

<Aside type="tip" title="The real win">
Your AppHost becomes the single source of truth for your application's architecture. New team members can understand your entire system by reading one file.
</Aside>

## Key benefits

- **Unified Development Experience**: Launch and debug your entire distributed application with a single command.
- **Code-First Configuration**: Define your app's architecture in code‚Äîno complex config files required.
- **Local Orchestration**: Automatically handle service startup, dependencies, and connections during development.
- **Deployment Flexibility**: Deploy to Kubernetes, cloud providers, or your own servers using the same architecture definition.
- **Extensible**: Integrate with your favorite tools and services through a rich ecosystem of integrations.

## How Aspire works

Aspire uses a **code-first approach** to define your application's architecture. Instead of managing complex configuration files, you describe your services, databases, and dependencies directly in code. This approach provides several advantages:

- **Type Safety**: Catch configuration errors at compile time.
- **Statement Completion Support**: Get code completion and documentation while defining your architecture.
- **Version Control**: Your infrastructure definition lives alongside your code.
- **Refactoring**: Use familiar development tools to restructure your application architecture.

<LearnMore>
  Discover how Aspire powers your applications through its
  [`AppHost`](/get-started/app-host/).
</LearnMore>

## Development vs production

Aspire bridges the gap between development and production environments:

- **Development**: Run services locally with automatic dependency management and service discovery
- **Production**: Deploy the same architecture definition to various cloud platforms and orchestrators
- **Consistency**: Ensure your local development environment matches your production topology

Aspire doesn't replace your existing deployment workflows‚Äîit enhances them by providing a consistent way to define and manage your application architecture across environments.

<LearnMore>
  Learn more about [Pipelines and App Topology](/get-started/pipelines/).
</LearnMore>
