---
title: Create custom client integrations
description: Learn how to create a custom Aspire client integration for an existing containerized application.
---

import { Image } from 'astro:assets';
import { Aside, Steps } from '@astrojs/starlight/components';
import { Kbd } from 'starlight-kbd/components';
import maildevWithNewsletterDashboard from '@assets/integrations/custom-integrations/maildev-with-newsletterservice-dashboard.png';
import swaggerUi from '@assets/integrations/custom-integrations/swagger-ui.png';
import swaggerUiTry from '@assets/integrations/custom-integrations/swagger-ui-try.png';
import maildevInbox from '@assets/integrations/custom-integrations/maildev-inbox.png';
import mailkitMetricsDashboard from '@assets/integrations/custom-integrations/mailkit-metrics-dashboard.png';
import mailkitMetricsGraphDashboard from '@assets/integrations/custom-integrations/mailkit-metrics-graph-dashboard.png';

This article is a continuation of the [Create custom hosting integrations](/integrations/custom-integrations/hosting-integrations/) article. It guides you through creating an Aspire client integration that uses [MailKit](https://github.com/jstedfast/MailKit) to send emails. This integration is then added into the Newsletter app you previously built. The previous example omitted the creation of a client integration and instead relied on the existing .NET `SmtpClient`. It's best to use MailKit's `SmtpClient` over the official .NET `SmtpClient` for sending emails, as it's more modern and supports more features/protocols. For more information, see [.NET SmtpClient: Remarks](https://learn.microsoft.com/dotnet/api/system.net.mail.smtpclient#remarks).

## Prerequisites

If you're following along, you should have a Newsletter app from the steps in the [Create custom hosting integrations](/integrations/custom-integrations/hosting-integrations/) article.

<Aside type="tip">
This article is inspired by existing Aspire integrations, and based on the team's official guidance. There are places where said guidance varies, and it's important to understand the reasoning behind the differences. For more information, see [Aspire integration requirements](https://github.com/dotnet/aspire/blob/f38b6cba86942ad1c45fc04fe7170f0fd4ba7c0b/src/Components/Aspire_Components_Progress.md#net-aspire-integration-requirements).
</Aside>

## Create library for integration

[Aspire integrations](/integrations/overview/) are delivered as NuGet packages, but in this example, it's beyond the scope of this article to publish a NuGet package. Instead, you create a class library project that contains the integration and reference it as a project. Aspire integration packages are intended to wrap a client library, such as MailKit, and provide production-ready telemetry, health checks, configurability, and testability. Let's start by creating a new class library project.

<Steps>
1. Create a new class library project named `MailKit.Client` in the same directory as the `MailDevResource.sln` from the previous article.

    ```dotnetcli
    dotnet new classlib -o MailKit.Client
    ```

2. Add the project to the solution.

    ```dotnetcli
    dotnet sln ./MailDevResource.sln add MailKit.Client/MailKit.Client.csproj
    ```
</Steps>

The next step is to add all the NuGet packages that the integration relies on. Add the following package references to your `MailKit.Client.csproj` file:

```xml
<ItemGroup>
  <PackageReference Include="MailKit" Version="4.9.0" />
  <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="9.0.0" />
  <PackageReference Include="OpenTelemetry" Version="1.10.0" />
</ItemGroup>
```

## Define integration settings

Whenever you're creating an Aspire integration, it's best to understand the client library that you're mapping to. With MailKit, you need to understand the configuration settings that are required to connect to a Simple Mail Transfer Protocol (SMTP) server. But it's also important to understand if the library has support for _health checks_, _tracing_ and _metrics_. MailKit supports _tracing_ and _metrics_, through its [`Telemetry.SmtpClient` class](https://github.com/jstedfast/MailKit/blob/master/MailKit/Telemetry.cs#L112-L189). When adding _health checks_, you should use any established or existing health checks where possible. Otherwise, you might consider implementing your own in the integration. Add the following code to the `MailKit.Client` project in a file named `MailKitClientSettings.cs`:

```csharp
namespace MailKit.Client;

using System.Net;

/// <summary>
/// Settings for configuring the MailKit SMTP client.
/// </summary>
public class MailKitClientSettings
{
    /// <summary>
    /// Gets or sets the SMTP server endpoint.
    /// </summary>
    public Uri? Endpoint { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether health checks are disabled.
    /// </summary>
    public bool DisableHealthChecks { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether tracing is disabled.
    /// </summary>
    public bool DisableTracing { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether metrics are disabled.
    /// </summary>
    public bool DisableMetrics { get; set; }

    /// <summary>
    /// Gets or sets the network credentials for the SMTP server.
    /// </summary>
    public NetworkCredential? Credentials { get; set; }

    /// <summary>
    /// Parses the connection string into a valid URI.
    /// </summary>
    /// <param name="connectionString">The connection string to parse.</param>
    /// <returns>The parsed URI.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the connection string is invalid.</exception>
    public static Uri ParseConnectionString(string connectionString)
    {
        if (string.IsNullOrEmpty(connectionString))
        {
            throw new InvalidOperationException("Connection string is missing.");
        }

        if (!Uri.TryCreate(connectionString, UriKind.Absolute, out var uri) ||
            uri.Scheme != "smtp")
        {
            throw new InvalidOperationException($"Invalid connection string: '{connectionString}'");
        }

        return uri;
    }
}
```

The preceding code defines the `MailKitClientSettings` class with:

- `Endpoint` property that represents the connection string to the SMTP server.
- `DisableHealthChecks` property that determines whether health checks are enabled.
- `DisableTracing` property that determines whether tracing is enabled.
- `DisableMetrics` property that determines whether metrics are enabled.
- `Credentials` property for storing username and password credentials.

### Parse connection string logic

The settings class also contains a `ParseConnectionString` method that parses the connection string into a valid `Uri`. The configuration is expected to be provided in the following format:

- `ConnectionStrings:<connectionName>`: The connection string to the SMTP server.
- `MailKit:Client:ConnectionString`: The connection string to the SMTP server.

If neither of these values are provided, an exception is thrown.

## Expose client functionality

The goal of Aspire integrations is to expose the underlying client library to consumers through dependency injection. With MailKit and for this example, the `SmtpClient` class is what you want to expose. You're not wrapping any functionality, but rather mapping configuration settings to an `SmtpClient` class. It's common to expose both standard and keyed-service registrations for integrations. Standard registrations are used when there's only one instance of a service, and keyed-service registrations are used when there are multiple instances of a service. Sometimes, to achieve multiple registrations of the same type you use a factory pattern. Add the following code to the `MailKit.Client` project in a file named `MailKitClientFactory.cs`:

```csharp
namespace MailKit.Client;

using MailKit.Net.Smtp;

/// <summary>
/// Factory for creating MailKit SMTP client instances.
/// </summary>
public class MailKitClientFactory(MailKitClientSettings settings)
{
    private ISmtpClient? _client;

    /// <summary>
    /// Gets or creates an SMTP client instance.
    /// </summary>
    /// <returns>The SMTP client instance.</returns>
    public async Task<ISmtpClient> GetSmtpClientAsync()
    {
        if (_client is not null)
        {
            return _client;
        }

        var client = new SmtpClient();

        if (settings.Endpoint is null)
        {
            throw new InvalidOperationException("SMTP endpoint is not configured.");
        }

        await client.ConnectAsync(settings.Endpoint.Host, settings.Endpoint.Port);

        if (settings.Credentials is not null)
        {
            await client.AuthenticateAsync(settings.Credentials);
        }

        _client = client;
        return _client;
    }

    /// <summary>
    /// Disposes the SMTP client if it exists.
    /// </summary>
    public void Dispose()
    {
        _client?.Disconnect(true);
        _client?.Dispose();
    }
}
```

The `MailKitClientFactory` class is a factory that creates an `ISmtpClient` instance based on the configuration settings. It's responsible for returning an `ISmtpClient` implementation that has an active connection to a configured SMTP server. Next, you need to expose the functionality for the consumers to register this factory with the dependency injection container. Add the following code to the `MailKit.Client` project in a file named `MailKitExtensions.cs`:

```csharp
namespace MailKit.Client;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using OpenTelemetry;
using MailKit.Telemetry;

/// <summary>
/// Extension methods for adding MailKit client integration to the service collection.
/// </summary>
public static class MailKitExtensions
{
    /// <summary>
    /// Adds MailKit SMTP client to the service collection.
    /// </summary>
    /// <param name="builder">The host application builder.</param>
    /// <param name="configureSettings">Optional action to configure settings.</param>
    /// <returns>The host application builder.</returns>
    public static IHostApplicationBuilder AddMailKitClient(
        this IHostApplicationBuilder builder,
        Action<MailKitClientSettings>? configureSettings = null)
    {
        return AddMailKitClientInternal(builder, null, configureSettings);
    }

    /// <summary>
    /// Adds a keyed MailKit SMTP client to the service collection.
    /// </summary>
    /// <param name="builder">The host application builder.</param>
    /// <param name="serviceKey">The service key for keyed dependency injection.</param>
    /// <param name="configureSettings">Optional action to configure settings.</param>
    /// <returns>The host application builder.</returns>
    public static IHostApplicationBuilder AddKeyedMailKitClient(
        this IHostApplicationBuilder builder,
        string serviceKey,
        Action<MailKitClientSettings>? configureSettings = null)
    {
        return AddMailKitClientInternal(builder, serviceKey, configureSettings);
    }

    private static IHostApplicationBuilder AddMailKitClientInternal(
        IHostApplicationBuilder builder,
        string? serviceKey,
        Action<MailKitClientSettings>? configureSettings)
    {
        var settings = new MailKitClientSettings();
        var connectionName = serviceKey ?? "mailkit";
        var connectionString = builder.Configuration.GetConnectionString(connectionName);

        if (string.IsNullOrEmpty(connectionString))
        {
            connectionString = builder.Configuration[$"MailKit:Client:ConnectionString"];
        }

        if (!string.IsNullOrEmpty(connectionString))
        {
            settings.Endpoint = MailKitClientSettings.ParseConnectionString(connectionString);
            var uri = settings.Endpoint;
            if (!string.IsNullOrEmpty(uri.UserInfo))
            {
                var parts = uri.UserInfo.Split(':');
                if (parts.Length == 2)
                {
                    settings.Credentials = new System.Net.NetworkCredential(parts[0], parts[1]);
                }
            }
        }

        configureSettings?.Invoke(settings);

        if (serviceKey is null)
        {
            builder.Services.AddScoped<MailKitClientFactory>(_ => new MailKitClientFactory(settings));
        }
        else
        {
            builder.Services.AddKeyedScoped<MailKitClientFactory>(serviceKey, (_, _) => new MailKitClientFactory(settings));
        }

        // Add health checks
        if (settings.DisableHealthChecks is false)
        {
            builder.Services.AddHealthChecks()
                .AddCheck<MailKitHealthCheck>(
                    name: serviceKey is null ? "MailKit" : $"MailKit_{connectionName}",
                    failureStatus: default,
                    tags: []);
        }

        // Add telemetry
        if (settings.DisableTracing is false)
        {
            builder.Services.AddOpenTelemetry()
                .WithTracing(
                    traceBuilder => traceBuilder.AddSource(
                        SmtpClient.ActivitySourceName));
        }

        if (settings.DisableMetrics is false)
        {
            SmtpClient.Configure();

            builder.Services.AddOpenTelemetry()
                .WithMetrics(
                    metricsBuilder => metricsBuilder.AddMeter(
                        SmtpClient.MeterName));
        }

        return builder;
    }
}
```

The preceding code adds two extension methods on the `IHostApplicationBuilder` type, one for the standard registration of MailKit and another for keyed-registration of MailKit.

<Aside type="tip">
Extension methods for Aspire integrations should extend the `IHostApplicationBuilder` type and follow the `Add<MeaningfulName>` naming convention where the `<MeaningfulName>` is the type or functionality you're adding. For this article, the `AddMailKitClient` extension method is used to add the MailKit client. It's likely more in-line with the official guidance to use `AddMailKitSmtpClient` instead of `AddMailKitClient`, since this only registers the `SmtpClient` and not the entire MailKit library.
</Aside>

Both extensions ultimately rely on the private `AddMailKitClient` method to register the `MailKitClientFactory` with the dependency injection container as a [scoped service](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#scoped). The reason for registering the `MailKitClientFactory` as a scoped service is because the connection operations are considered expensive and should be reused within the same scope where possible. In other words, for a single request, the same `ISmtpClient` instance should be used. The factory holds on to the instance of the `SmtpClient` that it creates and disposes of it.

### Configuration binding

One of the first things that the private implementation of the `AddMailKitClient` methods does, is to bind the configuration settings to the `MailKitClientSettings` class. The settings class is instantiated and then binding is performed with the specific section of configuration. Then the optional `configureSettings` delegate is invoked with the current settings. This allows the consumer to further configure the settings, ensuring that manual code settings are honored over configuration settings. After that, depending on whether the `serviceKey` value was provided, the `MailKitClientFactory` should be registered with the dependency injection container as either a standard or keyed service.

<Aside type="caution">
It's intentional that the `implementationFactory` overload is called when registering services. The `CreateMailKitClientFactory` method throws when the configuration is invalid. This ensures that creation of the `MailKitClientFactory` is deferred until it's needed and it prevents the app from erroring out before logging is available.
</Aside>

The registration of health checks, and telemetry are described in a bit more detail in the following sections.

### Add health checks

[Health checks](/docs/fundamentals/health-checks/) are a way to monitor the health of an integration. With MailKit, you can check if the connection to the SMTP server is healthy. Add the following code to the `MailKit.Client` project in a file named `MailKitHealthCheck.cs`:

```csharp
namespace MailKit.Client;

using Microsoft.Extensions.Diagnostics.HealthChecks;

/// <summary>
/// Health check for MailKit SMTP client.
/// </summary>
public class MailKitHealthCheck(MailKitClientFactory factory) : IHealthCheck
{
    /// <summary>
    /// Checks the health of the SMTP client connection.
    /// </summary>
    /// <param name="context">The health check context.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The health check result.</returns>
    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var client = await factory.GetSmtpClientAsync();
            if (client is null)
            {
                return HealthCheckResult.Unhealthy("SMTP client is not available.");
            }

            return HealthCheckResult.Healthy();
        }
        catch (Exception exception)
        {
            return HealthCheckResult.Unhealthy("SMTP client health check failed.", exception);
        }
    }
}
```

The preceding health check implementation:

<Steps>
1. Implements the `IHealthCheck` interface.
2. Accepts the `MailKitClientFactory` as a primary constructor parameter.
3. Satisfies the `CheckHealthAsync` method by:
   - Attempting to get an `ISmtpClient` instance from the `factory`. If successful, it returns `HealthCheckResult.Healthy`.
   - If an exception is thrown, it returns `HealthCheckResult.Unhealthy`.
</Steps>

As previously shared in the registration of the `MailKitClientFactory`, the `MailKitHealthCheck` is conditionally registered with the `IHeathChecksBuilder`:

```csharp
if (settings.DisableHealthChecks is false)
{
    builder.Services.AddHealthChecks()
        .AddCheck<MailKitHealthCheck>(
            name: serviceKey is null ? "MailKit" : $"MailKit_{connectionName}",
            failureStatus: default,
            tags: []);
}
```

The consumer could choose to omit health checks by setting the `DisableHealthChecks` property to `true` in the configuration. A common pattern for integrations is to have optional features and Aspire integrations strongly encourages these types of configurations. For more information on health checks and a working sample that includes a user interface, see [Aspire ASP.NET Core HealthChecksUI sample](/samples/dotnet/aspire-samples/aspire-health-checks-ui/).

### Wire up telemetry

As a best practice, the [MailKit client library exposes telemetry](https://github.com/jstedfast/MailKit/blob/master/Telemetry.md). Aspire can take advantage of this telemetry and display it in the [Aspire dashboard](/docs/dashboard/overview/). Depending on whether or not tracing and metrics are enabled, telemetry is wired up as shown in the following code snippet:

```csharp
if (settings.DisableTracing is false)
{
    builder.Services.AddOpenTelemetry()
        .WithTracing(
            traceBuilder => traceBuilder.AddSource(
                SmtpClient.ActivitySourceName));
}

if (settings.DisableMetrics is false)
{
    // Required by MailKit to enable metrics
    SmtpClient.Configure();

    builder.Services.AddOpenTelemetry()
        .WithMetrics(
            metricsBuilder => metricsBuilder.AddMeter(
                SmtpClient.MeterName));
}
```

## Update the Newsletter service

With the integration library created, you can now update the Newsletter service to use the MailKit client. The first step is to add a reference to the `MailKit.Client` project. Add the `MailKit.Client.csproj` project reference to the `MailDevResource.NewsletterService` project:

```dotnetcli
dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailKit.Client/MailKit.Client.csproj
```

Next, add a reference to the `ServiceDefaults` project:

```dotnetcli
dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailDevResource.ServiceDefaults/MailDevResource.ServiceDefaults.csproj
```

The final step is to replace the existing `Program.cs` file in the `MailDevResource.NewsletterService` project with the following C# code:

```csharp
using MailKit.Client;
using MailKit.Net.Smtp;
using MimeKit;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddOpenApi();
builder.AddServiceDefaults();
builder.AddMailKitClient();

var app = builder.Build();

app.MapOpenApi();
app.UseHttpsRedirection();

app.MapPost("/subscribe", async (string email, MailKitClientFactory factory) =>
{
    var client = await factory.GetSmtpClientAsync();
    var message = new MimeMessage();
    message.From.Add(new MailboxAddress("noreply", "noreply@newsletter.local"));
    message.To.Add(new MailboxAddress(email, email));
    message.Subject = "Welcome to the newsletter!";

    var bodyBuilder = new BodyBuilder
    {
        TextBody = "Welcome! You've subscribed to the newsletter."
    };

    message.Body = bodyBuilder.ToMessageBody();

    await client.SendAsync(message);

    return Results.Ok("Subscribed");
});

app.MapPost("/unsubscribe", async (string email, MailKitClientFactory factory) =>
{
    var client = await factory.GetSmtpClientAsync();
    var message = new MimeMessage();
    message.From.Add(new MailboxAddress("noreply", "noreply@newsletter.local"));
    message.To.Add(new MailboxAddress(email, email));
    message.Subject = "Goodbye from the newsletter";

    var bodyBuilder = new BodyBuilder
    {
        TextBody = "You have been unsubscribed from the newsletter."
    };

    message.Body = bodyBuilder.ToMessageBody();

    await client.SendAsync(message);

    return Results.Ok("Unsubscribed");
});

app.Run();
```

The most notable changes in the preceding code are:

<Steps>
1. The updated `using` statements that include the `MailKit.Client`, `MailKit.Net.Smtp`, and `MimeKit` namespaces.
2. The replacement of the registration for the official .NET `SmtpClient` with the call to the `AddMailKitClient` extension method.
3. The replacement of both `/subscribe` and `/unsubscribe` map post calls to instead inject the `MailKitClientFactory` and use the `ISmtpClient` instance to send the email.
</Steps>

## Run the sample

Now that you've created the MailKit client integration and updated the Newsletter service to use it, you can run the sample. From your IDE, select <Kbd mac="F5" windows="F5" /> or run `dotnet run` from the root directory of the solution to start the applicationâ€”you should see the [Aspire dashboard](/docs/dashboard/overview/):

<Image src={maildevWithNewsletterDashboard} alt="Aspire dashboard: MailDev and Newsletter resources running." />

Once the application is running, navigate to the Swagger UI at [https://localhost:7251/swagger](https://localhost:7251/swagger) and test the `/subscribe` and `/unsubscribe` endpoints. Select the down arrow to expand the endpoint:

<Image src={swaggerUi} alt="Swagger UI: Subscribe endpoint." />

Then select the `Try it out` button. Enter an email address, and then select the `Execute` button.

<Image src={swaggerUiTry} alt="Swagger UI: Subscribe endpoint with email address." />

Repeat this several times, to add multiple email addresses. You should see the email sent to the MailDev inbox:

<Image src={maildevInbox} alt="MailDev inbox with multiple emails." />

Stop the application by selecting <Kbd mac="Command+C" windows="Control+C" /> in the terminal window where the application is running, or by selecting the stop button in your IDE.

### View MailKit telemetry

The MailKit client library exposes telemetry that can be viewed in the Aspire dashboard. To view the telemetry, navigate to the Aspire dashboard at [https://localhost:7251](https://localhost:7251). Select the `newsletter` resource to view the telemetry on the **Metrics** page:

<Image src={mailkitMetricsDashboard} alt="Aspire dashboard: MailKit telemetry." />

Open up the Swagger UI again, and make some requests to the `/subscribe` and `/unsubscribe` endpoints. Then, navigate back to the Aspire dashboard and select the `newsletter` resource. Select a metric under the **mailkit.net.smtp** node, such as `mailkit.net.smtp.client.operation.count`. You should see the telemetry for the MailKit client:

<Image src={mailkitMetricsGraphDashboard} alt="Aspire dashboard: MailKit telemetry for operation count." />

## Summary

In this article, you learned how to create an Aspire integration that uses MailKit to send emails. You also learned how to integrate this integration into the Newsletter app you previously built. You learned about the core principles of Aspire integrations, such as exposing the underlying client library to consumers through dependency injection, and how to add health checks and telemetry to the integration. You also learned how to update the Newsletter service to use the MailKit client.

Go forth and build your own Aspire integrations. If you believe that there's enough community value in the integration you're building, consider publishing it as a [NuGet package](https://learn.microsoft.com/dotnet/standard/library-guidance/nuget) for others to use. Furthermore, consider submitting a pull request to the [Aspire GitHub repository](https://github.com/dotnet/aspire) for consideration to be included in the official Aspire integrations.

## Next steps

- [Secure communication between integrations](/integrations/custom-integrations/secure-communication/)
