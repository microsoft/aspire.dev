[
  {
    "name": "aspire-shop",
    "title": "Aspire Shop",
    "description": "The app consists of four .NET services:\n\n- **AspireShop.Frontend**: This is an ASP.NET Core Blazor app that displays a paginated catlog of products and allows users to add products to a shopping cart.\n- **AspireShop.CatalogService**: This is an HTTP API that provides access to the catalog of products stored in a PostgreSQL database.\n- **AspireShop.CatalogDbManager**: This is an HTTP API that manages the initialization and updating of the catalog database.\n- **AspireShop.BasketService**: This is a gRPC service that provides access to the shopping cart stored in Redis.\n\nThe app also includes a .NET class library project, **AspireShop.ServiceDefaults**, that contains the code-based defaults used by the .NET service projects.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/aspire-shop",
    "readme": "# Aspire Shop\n\n![Screenshot of the web front end the Aspire Shop sample](~/assets/samples/aspire-shop/aspireshop-frontend-complete.png)\n\nThe app consists of four .NET services:\n\n- **AspireShop.Frontend**: This is an ASP.NET Core Blazor app that displays a paginated catlog of products and allows users to add products to a shopping cart.\n- **AspireShop.CatalogService**: This is an HTTP API that provides access to the catalog of products stored in a PostgreSQL database.\n- **AspireShop.CatalogDbManager**: This is an HTTP API that manages the initialization and updating of the catalog database.\n- **AspireShop.BasketService**: This is a gRPC service that provides access to the shopping cart stored in Redis.\n\nThe app also includes a .NET class library project, **AspireShop.ServiceDefaults**, that contains the code-based defaults used by the .NET service projects.\n\n## Prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `AspireShop.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `AspireShop.slnx` and launch/debug the `AspireShop.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `AspireShop.AppHost` directory.\n",
    "tags": [
      "blazor",
      "csharp",
      "databases",
      "grpc",
      "postgresql",
      "redis"
    ],
    "thumbnail": "~/assets/samples/aspire-shop/aspireshop-frontend-complete.png"
  },
  {
    "name": "aspire-with-azure-functions",
    "title": "Image Gallery",
    "description": "The app consists of two services:\n\n- **ImageGallery.Frontend**: This is a Blazor app that displays a for uploading of images, showing thumbnails of images in a grid.\n- **ImageGallery.Functions**: This is an Azure Function triggered by the arrival of a new blob using a Functions Blob Trigger.\n\nThe app also includes a class library project, **ImageGallery.ServiceDefaults**, that contains the service defaults used by the service projects, and the **ImageGallery.AppHost** Aspire App Host project.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/aspire-with-azure-functions",
    "readme": "# Image Gallery\n\n![Screenshot of the web frontend the Aspire with Azure Functions sample](~/assets/samples/aspire-with-azure-functions/aspire-with-functions.png)\n\nThe app consists of two services:\n\n- **ImageGallery.Frontend**: This is a Blazor app that displays a for uploading of images, showing thumbnails of images in a grid.\n- **ImageGallery.Functions**: This is an Azure Function triggered by the arrival of a new blob using a Functions Blob Trigger.\n\nThe app also includes a class library project, **ImageGallery.ServiceDefaults**, that contains the service defaults used by the service projects, and the **ImageGallery.AppHost** Aspire App Host project.\n\n## Pre-requisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n- [Azure Functions tools](https://learn.microsoft.com/azure/azure-functions/functions-run-local?tabs=windows%2Cisolated-process%2Cnode-v4%2Cpython-v2%2Chttp-trigger%2Ccontainer-apps&pivots=programming-language-csharp)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `ImageGallery.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `ImageGallery.slnx` and launch/debug the `ImageGallery.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `ImageGallery.AppHost` directory.\n",
    "tags": [
      "azure",
      "azure-functions",
      "blazor",
      "csharp"
    ],
    "thumbnail": "~/assets/samples/aspire-with-azure-functions/aspire-with-functions.png"
  },
  {
    "name": "aspire-with-javascript",
    "title": "Integrating Angular, React, and Vue with Aspire",
    "description": "This sample demonstrates using the Aspire JavaScript hosting integration to configure and run client-side applications.\n\nThe app consists of four services:\n\n- **AspireJavaScript.MinimalApi**: This is an HTTP API that returns randomly generated weather forecast data.\n- **AspireJavaScript.Angular**: This is an Angular app that consumes the weather forecast API and displays the data in a table.\n- **AspireJavaScript.React**: This is a React app that consumes the weather forecast API and displays the data in a table.\n- **AspireJavaScript.Vue**: This is a Vue app that consumes the weather forecast API and displays the data in a table.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/aspire-with-javascript",
    "readme": "# Integrating Angular, React, and Vue with Aspire\n\nThis sample demonstrates using the Aspire JavaScript hosting integration to configure and run client-side applications.\n\nThe app consists of four services:\n\n- **AspireJavaScript.MinimalApi**: This is an HTTP API that returns randomly generated weather forecast data.\n- **AspireJavaScript.Angular**: This is an Angular app that consumes the weather forecast API and displays the data in a table.\n- **AspireJavaScript.React**: This is a React app that consumes the weather forecast API and displays the data in a table.\n- **AspireJavaScript.Vue**: This is a Vue app that consumes the weather forecast API and displays the data in a table.\n\n## Pre-requisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n- [Node.js](https://nodejs.org) - at least version 24.x\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `AspireShop.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `AspireShop.slnx` and launch/debug the `AspireShop.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `AspireShop.AppHost` directory.\n\n### Experiencing the app\n\nOnce the app is running, the Aspire dashboard will launch in your browser:\n\n![Aspire dashboard](~/assets/samples/aspire-with-javascript/aspire-dashboard.png)\n\nFrom the dashboard, you can navigate to the Angular, React, and Vue apps:\n\n**Angular**\n\n![Angular app](~/assets/samples/aspire-with-javascript/angular-app.png)\n\n**React**\n\n![React app](~/assets/samples/aspire-with-javascript/react-app.png)\n\n**Vue**\n\n![Vue app](~/assets/samples/aspire-with-javascript/vue-app.png)\n",
    "tags": [
      "csharp",
      "dashboard",
      "javascript",
      "node"
    ],
    "thumbnail": "~/assets/samples/aspire-with-javascript/aspire-dashboard.png"
  },
  {
    "name": "aspire-with-node",
    "title": "Integrating a Node.js app within an Aspire application",
    "description": "This sample demonstrates integrating a Node.js app and an ASP.NET Core HTTP API using Aspire.\n\nThe sample consists of two apps:\n\n- **NodeFrontend**: This is a simple Express-based Node.js app that renders a table of weather forecasts retrieved from a backend API and utilizes a Redis cache.\n- **AspireWithNode.AspNetCoreApi**: This is an ASP.NET Core HTTP API that returns randomly generated weather forecast data.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/aspire-with-node",
    "readme": "# Integrating a Node.js app within an Aspire application\n\nThis sample demonstrates integrating a Node.js app and an ASP.NET Core HTTP API using Aspire.\n\nThe sample consists of two apps:\n\n- **NodeFrontend**: This is a simple Express-based Node.js app that renders a table of weather forecasts retrieved from a backend API and utilizes a Redis cache.\n- **AspireWithNode.AspNetCoreApi**: This is an ASP.NET Core HTTP API that returns randomly generated weather forecast data.\n\n## Prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [Node.js](https://nodejs.org) - at least version 22.21.1\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `AspireWithNode.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `AspireWithNode.slnx` and launch/debug the `AspireWithNode.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `AspireWithNode.AppHost` directory.\n",
    "tags": [
      "csharp",
      "javascript",
      "node",
      "redis"
    ],
    "thumbnail": null
  },
  {
    "name": "aspire-with-python",
    "title": "Integrating a FastAPI (Python) app within an Aspire application",
    "description": "This sample demonstrates integrating a FastAPI (Python) app and a JavaSript frontend using Aspire.\n\nThe sample consists of two apps:\n\n- **app**: This is a simple FastAPI-based Python app that returns randomly generated weather forecast data.\n- **frontend**: This is a Vite-based React app that renders the weather forecast data.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/aspire-with-python",
    "readme": "# Integrating a FastAPI (Python) app within an Aspire application\n\nThis sample demonstrates integrating a FastAPI (Python) app and a JavaSript frontend using Aspire.\n\nThe sample consists of two apps:\n\n- **app**: This is a simple FastAPI-based Python app that returns randomly generated weather forecast data.\n- **frontend**: This is a Vite-based React app that renders the weather forecast data.\n\n## Prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [Python](https://www.python.org/) - at least version 3.13\n- [Node.js](https://nodejs.org) - at least version 22.21.1\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `apphost.cs` C# file using either the Aspire or C# debuggers.\n",
    "tags": [
      "csharp",
      "javascript",
      "node",
      "python"
    ],
    "thumbnail": null
  },
  {
    "name": "client-apps-integration",
    "title": "Working with client apps in an Aspire application",
    "description": "This sample demonstrates working with client apps such as WinForms, WPF, etc., in an Aspire app, such that the client app is launched along with the AppHost project, can resolve services via service discovery, and logs, traces, and metrics are sent via OpenTelemetry to the dashboard.\n\n\nThe app is based on the Aspire Starter App template, with the following additional elements:\n\n- **ClientAppsIntegration.WinForms**: This is a WinForms application that displays the results of calling the weather API service application.\n- **ClientAppsIntegration.WPF**: This is a WPF application that displays the results of calling the weather API service application.\n- **ClientAppsIntegration.AppDefaults**: This is a class library that defines the default configuration for orchestrated apps. It's a more general version of the typical `ServiceDefaults` class library that's included in Aspire apps. The `ClientAppsIntegration.WinForms` and `ClientAppsIntegration.WPF` projects reference this project and calls its `AddAppDefaults()` method.\n- **ClientAppsIntegration.ServiceDefaults**: This has been modified from the default `ServiceDefaults` template to be based on and extend the `ClientAppsIntegration.AppDefaults` class library. The `ClientAppsIntegration.ApiService` project references this project and calls its `AddServiceDefaults()` method.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/client-apps-integration",
    "readme": "# Working with client apps in an Aspire application\n\nThis sample demonstrates working with client apps such as WinForms, WPF, etc., in an Aspire app, such that the client app is launched along with the AppHost project, can resolve services via service discovery, and logs, traces, and metrics are sent via OpenTelemetry to the dashboard.\n\n![Screenshot of the WinForms app running and the Aspire dashboard behind it showing traces emitted from the client app.](~/assets/samples/client-apps-integration/client-apps-dashboard-winforms.png)\n\nThe app is based on the Aspire Starter App template, with the following additional elements:\n\n- **ClientAppsIntegration.WinForms**: This is a WinForms application that displays the results of calling the weather API service application.\n- **ClientAppsIntegration.WPF**: This is a WPF application that displays the results of calling the weather API service application.\n- **ClientAppsIntegration.AppDefaults**: This is a class library that defines the default configuration for orchestrated apps. It's a more general version of the typical `ServiceDefaults` class library that's included in Aspire apps. The `ClientAppsIntegration.WinForms` and `ClientAppsIntegration.WPF` projects reference this project and calls its `AddAppDefaults()` method.\n- **ClientAppsIntegration.ServiceDefaults**: This has been modified from the default `ServiceDefaults` template to be based on and extend the `ClientAppsIntegration.AppDefaults` class library. The `ClientAppsIntegration.ApiService` project references this project and calls its `AddServiceDefaults()` method.\n\n## Pre-requisites\n\n- A Windows OS supported by .NET 10 (e.g. Windows 11)\n- [Aspire development environment](https://aspire.dev/get-stated/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n- [Visual Studio 2026](https://visualstudio.microsoft.com/vs/)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using Visual Studio, open the solution file `ClientAppsIntegration.slnx` and launch/debug the `ClientAppsIntegration.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `ClientAppsIntegration.AppHost` directory.\n\nIn the launched WinForms and WPF app, click on \"Load Weather\" button to have the app call the backend weather API and populate the grid with the results. To explore the error condition behavior, check the \"Force Error\" checkbox and click on the \"Load Weather\" button again.\n\nIn the Aspire dashboard, use the logs, traces, and metrics pages to see telemtry emitted from the client apps.\n",
    "tags": [
      "csharp",
      "dashboard",
      "metrics"
    ],
    "thumbnail": "~/assets/samples/client-apps-integration/client-apps-dashboard-winforms.png"
  },
  {
    "name": "container-build",
    "title": "Working with container-built resources in a Aspire application",
    "description": "This sample demonstrates integrating applications into a Aspire app via Dockerfiles and container-based builds. This is especially helpful to integrate applications written in languages that Aspire does not have a native integration for, or to reduce the prerequisites required to run the application.\n\n\nThe sample integrates a simple app written using [Go](https://go.dev/) and the [Gin Web Framework](https://gin-gonic.com/) by using a [Dockerfile](./ginapp/Dockerfile):\n\n- **ginapp**: This is a simple \"Hello, World\" HTTP API that returns a JSON object like `{ \"message\": \"Hello, World!\" }` from `/` and sends OpenTelemetry instrumentation to the Aspire dashboard.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/container-build",
    "readme": "# Working with container-built resources in a Aspire application\n\nThis sample demonstrates integrating applications into a Aspire app via Dockerfiles and container-based builds. This is especially helpful to integrate applications written in languages that Aspire does not have a native integration for, or to reduce the prerequisites required to run the application.\n\n![Screenshot of the Aspire dashboard showing the ginapp container resource built from a Dockerfile](~/assets/samples/container-build/aspire-dashboard-container-build.png)\n\nThe sample integrates a simple app written using [Go](https://go.dev/) and the [Gin Web Framework](https://gin-gonic.com/) by using a [Dockerfile](./ginapp/Dockerfile):\n\n- **ginapp**: This is a simple \"Hello, World\" HTTP API that returns a JSON object like `{ \"message\": \"Hello, World!\" }` from `/` and sends OpenTelemetry instrumentation to the Aspire dashboard.\n\n## Development Features\n\nThis sample includes **hot reload** for local development! The Go application uses:\n\n- **Bind mounts** - Your local source code is mounted directly into the container at `/app`\n- **[Air](https://github.com/air-verse/air)** - A live reload tool for Go that watches for file changes and rebuilds automatically\n- **Polling-based file watching** - Configured to work reliably with Docker bind mounts on Windows\n\nWhen you edit any `.go` file in the `ginapp` directory, Air automatically detects the change, rebuilds the Go binary, and restarts the app in just a few secondsâ€”without rebuilding the entire container. This provides a much faster development feedback loop compared to full container rebuilds.\n\n### How it works\n\n- **Development mode** (default): Uses `Dockerfile.dev` with Air for hot reload\n  - Source files are bind-mounted from your local machine\n  - Changes to `.go` files trigger automatic rebuilds\n  - Dependencies are resolved on-demand via `go get`\n\n- **Production mode** (`aspire publish`): Uses the standard `Dockerfile`\n  - Multi-stage build for optimized images\n  - No bind mounts or development tools\n  - Minimal runtime container based on distroless images\n\n## Pre-requisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `apphost.cs` file using either the Aspire or C# debuggers.\n\nIf using the .NET CLI, run `dotnet run apphost.cs` from this directory.\n\nFrom the Aspire dashboard, click on the endpoint URL for the `ginapp` resource to see the response in the browser.\n",
    "tags": [
      "csharp",
      "dashboard",
      "docker",
      "metrics"
    ],
    "thumbnail": "~/assets/samples/container-build/aspire-dashboard-container-build.png"
  },
  {
    "name": "custom-resources",
    "title": "Writing custom resources for Aspire hosting integrations",
    "description": "This sample demonstrates how to write custom resources for Aspire hosting integrations. This is useful when you want to integrate something into the Aspire development experience as a resource that isn't an executable or container. Custom resources can particpate in the Aspire development experience, including the dashboard, and can be used to integrate with other tools or services.\n\nCustom resources are defined using C# and generally consist of a class that implements the `IResource` interface and some extension methods to enable adding them to an `IDistributedApplicationBuilder`. Custom resources can publish and respond to events to give them \"life\" and allow them to interact with the rest of the Aspire application.\n\nIn this sample, we define a `TalkingClock` custom resource that spawns child `ClockHand` resources that tick on and off every second. We also define a `TestResource` custom resource that simply cycles through a set of states.\n\nRead more about the [Aspire resource model here](https://gist.github.com/davidfowl/b408af870d4b5b54a28bf18bffa127e1).",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/custom-resources",
    "readme": "# Writing custom resources for Aspire hosting integrations\n\nThis sample demonstrates how to write custom resources for Aspire hosting integrations. This is useful when you want to integrate something into the Aspire development experience as a resource that isn't an executable or container. Custom resources can particpate in the Aspire development experience, including the dashboard, and can be used to integrate with other tools or services.\n\nCustom resources are defined using C# and generally consist of a class that implements the `IResource` interface and some extension methods to enable adding them to an `IDistributedApplicationBuilder`. Custom resources can publish and respond to events to give them \"life\" and allow them to interact with the rest of the Aspire application.\n\nIn this sample, we define a `TalkingClock` custom resource that spawns child `ClockHand` resources that tick on and off every second. We also define a `TestResource` custom resource that simply cycles through a set of states.\n\nRead more about the [Aspire resource model here](https://gist.github.com/davidfowl/b408af870d4b5b54a28bf18bffa127e1).\n\n## Prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `CustomResources.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `CustomResources.slnx` and launch/debug the `CustomResources.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `CustomResources.AppHost` directory.\n",
    "tags": [
      "csharp",
      "dashboard"
    ],
    "thumbnail": null
  },
  {
    "name": "database-containers",
    "title": "Working with database containers in a Aspire application",
    "description": "This sample demonstrates working with database containers in a Aspire app, using the features of the underlying container image to modify the default database created during container startup. This is especially helpful when not using an ORM like Entity Framework Core that can run migrations on application startup (e.g., [as in the Aspire Shop sample](../AspireShop/AspireShop.CatalogDbManager)) and handle cases when the database configured in the AppHost is not yet created.\n\n\nThe app uses the following database container types:\n\n- [Microsoft SQL Server](https://mcr.microsoft.com/en-us/product/mssql/server/about)\n- [MySQL](https://hub.docker.com/_/mysql)\n- [PostgreSQL](https://hub.docker.com/_/postgres/)\n\nThe app consists of an API service:\n\n- **ContainerDatabases.ApiService**: This is an HTTP API that returns data from each of the configured databases.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/database-containers",
    "readme": "# Working with database containers in a Aspire application\n\nThis sample demonstrates working with database containers in a Aspire app, using the features of the underlying container image to modify the default database created during container startup. This is especially helpful when not using an ORM like Entity Framework Core that can run migrations on application startup (e.g., [as in the Aspire Shop sample](../AspireShop/AspireShop.CatalogDbManager)) and handle cases when the database configured in the AppHost is not yet created.\n\n![Screenshot of the Swagger UI for the API service that returns data from the configured database containers](~/assets/samples/database-containers/db-containers-apiservice-swagger-ui.png)\n\nThe app uses the following database container types:\n\n- [Microsoft SQL Server](https://mcr.microsoft.com/en-us/product/mssql/server/about)\n- [MySQL](https://hub.docker.com/_/mysql)\n- [PostgreSQL](https://hub.docker.com/_/postgres/)\n\nThe app consists of an API service:\n\n- **ContainerDatabases.ApiService**: This is an HTTP API that returns data from each of the configured databases.\n\n## Prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `DatabaseContainers.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `DatabaseContainers.slnx` and launch/debug the `DatabaseContainers.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `DatabaseContainers.AppHost` directory.\n\nFrom the Aspire dashboard, click on the endpoint URL for the `DatabaseContainers.ApiService` project to launch the Swagger UI for the APIs. You can use the UI to call the APIs and see the results.\n",
    "tags": [
      "csharp",
      "dashboard",
      "databases",
      "docker",
      "ef-core",
      "migrations",
      "mysql",
      "postgresql",
      "sql-server"
    ],
    "thumbnail": "~/assets/samples/database-containers/db-containers-apiservice-swagger-ui.png"
  },
  {
    "name": "database-migrations",
    "title": "Database migrations with Entity Framework Core sample app",
    "description": "This sample demonstrates how to use Entity Framework Core's [migrations feature](https://learn.microsoft.com/ef/core/managing-schemas/migrations) with Aspire.\n\nThe sample has three important projects:\n\n- `DatabaseMigrations.ApiService` - A web app that uses the database.\n- `DatabaseMigrations.MigrationService` - A background worker app that applies migrations when it starts up.\n- `DatabaseMigrations.ApiModel` - The EF Core context and entity types. This project is used by both the API and migration service.\n\n`DatabaseMigrations.ApiService` and `DatabaseMigrations.MigrationService` reference a SQL Server resource. During local development the SQL Server resource is launched in a container.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/database-migrations",
    "readme": "# Database migrations with Entity Framework Core sample app\n\nThis sample demonstrates how to use Entity Framework Core's [migrations feature](https://learn.microsoft.com/ef/core/managing-schemas/migrations) with Aspire.\n\nThe sample has three important projects:\n\n- `DatabaseMigrations.ApiService` - A web app that uses the database.\n- `DatabaseMigrations.MigrationService` - A background worker app that applies migrations when it starts up.\n- `DatabaseMigrations.ApiModel` - The EF Core context and entity types. This project is used by both the API and migration service.\n\n`DatabaseMigrations.ApiService` and `DatabaseMigrations.MigrationService` reference a SQL Server resource. During local development the SQL Server resource is launched in a container.\n\n## Demonstrates\n\n- How to create migrations in an Aspire solution\n- How to apply migrations in an Aspire solution\n\n## Sample prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- This sample is written in C# and targets .NET 10. It requires the [.NET 10.0 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later.\n- The `dotnet ef` .NET tool is required. It can be installed by running the following in a terminal:\n\n    ```shell\n    dotnet tool install --global dotnet-ef\n    ```\n\n## Create migration\n\nThe `DatabaseMigrations.MigrationService` project contains the EF Core migrations. The [`dotnet ef` command-line tool](https://learn.microsoft.com/ef/core/managing-schemas/migrations/#install-the-tools) can be used to create new migrations:\n\n1. Update the `Entry` entity in database context in `MyDb1Context.cs`. Add a `Name` property:\n\n    ```cs\n    public class Entry\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string? Name { get; set; }\n    }\n    ```\n\n2. Open a command prompt in the `DatabaseMigrations.MigrationService` directory and run the EF Core migration tool to create a migration named **MyNewMigration**.\n\n    ```bash\n    dotnet ef migrations add MyNewMigration\n    ```\n\n    The preceding command:\n\n      - Runs EF Core migration command-line tool in the `DatabaseMigrations.MigrationService` directory.\n        - `dotnet ef` is run in this location because it will be used as the default target project for the new migration and the tool will run the startup code in `Program.cs` to find and configure the context to be used.\n      - Creates the migration named `MyNewMigration` in the `DatabaseMigrations.MigrationService` project.\n\n    > [!NOTE]\n    > Other EF Core providers can impose different requirements for creating migrations. For example, the Npgsql provider requires a well-formed connection string to be present in the application's configuration, e.g. the `appsettings.Development.json` file, for the `DbContext` the migrations are being created for. The connection string need not be to an actual database, but it must be able to be successfully parsed. The SQL Server provider does not have this requirement.\n\n3. View the new migration files in the `DatabaseMigrations.ApiModel` project.\n\n> [!NOTE]\n> To remove the unapplied migration you need to run `dotnet ef migrations remove --force`.  The `--force` switch tells the tool to avoid connecting to the database\n\n## Run the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `DatabaseMigrations.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `DatabaseMigrations.slnx` and launch/debug the `DatabaseMigrations.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `DatabaseMigrations.AppHost` directory.\n\nWhen the app starts up, the `DatabaseMigrations.MigrationService` background worker runs migrations on the SQL Server container. The migration service:\n\n- Creates a database in the SQL Server container.\n- Creates the database schema.\n- Stops itself once the migration is complete.\n",
    "tags": [
      "csharp",
      "databases",
      "ef-core",
      "migrations",
      "postgresql",
      "sql-server"
    ],
    "thumbnail": null
  },
  {
    "name": "health-checks-ui",
    "title": "Configuring health checks & running the ASP.NET Core HealthChecksUI container with Aspire",
    "description": "This sample demonstrates configuring [ASP.NET Core Health Checks](https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks) and running the [ASP.NET Core HealthChecksUI container](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/doc/ui-docker.md) with Aspire.\n\n\nThe sample is based on the Aspire Starter App project template and thus consists of a frontend Blazor app that communicates with a backend ASP.NET Core API service and a Redis cache.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/health-checks-ui",
    "readme": "# Configuring health checks & running the ASP.NET Core HealthChecksUI container with Aspire\n\nThis sample demonstrates configuring [ASP.NET Core Health Checks](https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks) and running the [ASP.NET Core HealthChecksUI container](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/doc/ui-docker.md) with Aspire.\n\n![Screenshot of the HealthChecksUI](~/assets/samples/health-checks-ui/healthchecksui.png)\n\nThe sample is based on the Aspire Starter App project template and thus consists of a frontend Blazor app that communicates with a backend ASP.NET Core API service and a Redis cache.\n\n## Prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `HealthChecksUI.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `HealthChecksUI.slnx` and launch/debug the `HealthChecksUI.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `HealthChecksUI.AppHost` directory.\n\nFrom the Aspire dashboard, click on the endpoint URL for the `healthchecksui` resource to launch the HealthChecksUI.\n\n## Details about the health checks endpoint configuration\n\nAspire Service Defaults projects configure [health checks and add health checks endpoints by default](https://aspire.dev/fundamentals/health-checks/). However, the endpoints are not exposed in [non-development environments](https://aspire.dev/fundamentals/health-checks/#non-development-environments) by default as doing so has security implications. This sample demonstrates how the default health checks endpoints can be customized to ensure they timeout if execution takes longer than expected, and that the results are cached so that repeated requests do not cause excessive load on the system.\n\nThe `AddDefaultHealthChecks` method in the `HealthChecksUI.ServiceDefaults` project adds and configures the [Output Caching](https://learn.microsoft.com/aspnet/core/performance/caching/output) and [Request Timeouts](https://learn.microsoft.com/aspnet/core/performance/timeouts) features of ASP.NET Core via named policies that are then applied to the health checks endpoints in the `MapDefaultEndpoints` method:\n\n```csharp\npublic static IHostApplicationBuilder AddDefaultHealthChecks(this IHostApplicationBuilder builder)\n{\n    var healthChecksConfiguration = builder.Configuration.GetSection(\"HealthChecks\");\n\n    // All health checks endpoints must return within the configured timeout value (defaults to 5 seconds)\n    var healthChecksRequestTimeout = healthChecksConfiguration.GetValue<TimeSpan?>(\"RequestTimeout\") ?? TimeSpan.FromSeconds(5);\n    builder.Services.AddRequestTimeouts(timeouts => timeouts.AddPolicy(\"HealthChecks\", healthChecksRequestTimeout));\n\n    // Cache health checks responses for the configured duration (defaults to 10 seconds)\n    var healthChecksExpireAfter = healthChecksConfiguration.GetValue<TimeSpan?>(\"ExpireAfter\") ?? TimeSpan.FromSeconds(10);\n    builder.Services.AddOutputCache(caching => caching.AddPolicy(\"HealthChecks\", policy => policy.Expire(healthChecksExpireAfter)));\n\n    builder.Services.AddHealthChecks()\n        // Add a default liveness check to ensure app is responsive\n        .AddCheck(\"self\", () => HealthCheckResult.Healthy(), [\"live\"]);\n\n    return builder;\n}\n```\n\nIn addition to the default health checks endpoints at `/health` and `/alive`, this sample configures an additional health checks endpoint that returns more detailed information regarding the indiviaul configured health checks (rather than just a \"Healthy\" or \"Unhealthy\" status). This endpoint is consumed by the HealthChecksUI container to display a more detailed view of the health of the application. Because it contains more detailed information, it is configured to only be available when requested via a dedicated additional address that the application listens on, i.e. if the app serves regular HTTP traffic via `http://localhost:5000`, the detailed health checks endpoint will only be available via `http://localhost:5001/` (note the different port). Separating the detailed health checks endpoint onto a different port allows for it to be routed differently and, for example, only exposed to internal services. The app uses the [`RequireHost`](https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks#require-host) method to ensure the detailed health checks endpoint is only served to requests coming via the additional address:\n\n```csharp\n// Add the health checks endpoint for the HealthChecksUI\nvar healthChecksUrls = app.Configuration[\"HEALTHCHECKSUI_URLS\"];\nif (!string.IsNullOrWhiteSpace(healthChecksUrls))\n{\n    var pathToHostsMap = GetPathToHostsMap(healthChecksUrls);\n\n    foreach (var path in pathToHostsMap.Keys)\n    {\n        // Ensure that the HealthChecksUI endpoint is only accessible from configured hosts, e.g. localhost:12345, hub.docker.internal, etc.\n        // as it contains more detailed information about the health of the app including the types of dependencies it has.\n\n        healthChecks.MapHealthChecks(path, new() { ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse })\n            // This ensures that the HealthChecksUI endpoint is only accessible from the configured health checks URLs.\n            // See this documentation to learn more about restricting access to health checks endpoints via routing:\n            // https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-8.0#use-health-checks-routing\n            .RequireHost(pathToHostsMap[path]);\n    }\n}\n```\n\nWhen [deployed to Azure Container Apps (ACA) using the Aspire CLI](https://aspire.dev/integrations/cloud/azure/overview/#publish-as-azure-container-app), the additional endpoint will be automatically configured to be only accessible from the internal network of the ACA environment (as an [additional ingress TCP port](https://learn.microsoft.com/azure/container-apps/ingress-overview#additional-tcp-ports)), while the main HTTP endpoint will be configured for [external access](https://learn.microsoft.com/azure/container-apps/ingress-overview#external-and-internal-ingress) via the ACA app ingress rules. This ensures that the detailed health checks endpoint isn't exposed to the public internet, while the main HTTP(S) endpoint is (due to the call to `WithExternalHttpEndpoints()` on the app's resource in the app host project).\n\nThe diagram below illustrates the deployment of the sample app to Azure Container Apps with the HealthChecksUI container. You can see that there are **two** arraws pointing in to the `webfrontend` container, indicating the two separate ingress endpoints it's configured with, the main external HTTP(S) endpoint, and the addition internal TCP endpoint that the `healthchecksui` container is using to access the `/healthz` endpoint:\n\n![Diagram of deployed sampled in Azure Container Apps](~/assets/samples/health-checks-ui/aca-diagram.svg)\n\nNote that the HealthChecksUI dashboard is configured for external access in this sample for simplicity's sake, but in a real-world scenario, you likely want to require authentication to access the dashboard, e.g. via a custom reverse-proxy that enforces authentication and authorization rules.\n\n## Details about the hosting extension for the HealthChecksUI container\n\nThe HealthChecksUI container is integrated into this sample by way of a custom hosting extension, i.e. some C# that adds new types and extension methods to the core object model exposed by `Aspire.Hosting`. The extension is defined in the `HealthChecksUI.AppHost` project in the `HealthChecksUIResource.cs` and `HealthChecksUIExtensions.cs` files. The extensions demonstrate how existing containers can be integrated into the Aspire hosting model, allowing them to be managed and deployed alongside other resources in the same way as built-in resources like ASP.NET Core projects, Redis instances, database containers, and cloud services.\n\nA key aspect of this sample is that the extensions demonstrate how custom overloads of the `WithReference` method can be used to configure both the source and the target resources of the reference. In this case, calling `WithReference` on a HealthChecksUI resource and passing in a project resource results in both resources being configured to enable the scenario:\n\n- The project resource is configured to expose an additional endpoint to host the detailed health checks endpoint on as well as receiving the path that endpoint should be available at (`/healthz` by default)\n- The HealthChecksUI resource is configured to add the project resource's detailed health check endpoint as an one to include in the set it monitors for health check status.\n",
    "tags": [
      "azure",
      "blazor",
      "csharp",
      "dashboard",
      "databases",
      "docker",
      "health-checks",
      "redis"
    ],
    "thumbnail": "~/assets/samples/health-checks-ui/healthchecksui.png"
  },
  {
    "name": "Metrics",
    "title": "Aspire metrics sample app",
    "description": "This is a simple .NET app that shows off collecting metrics with OpenTelemetry and exporting them to Prometheus and Grafana for reporting.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/Metrics",
    "readme": "# Aspire metrics sample app\n\nThis is a simple .NET app that shows off collecting metrics with OpenTelemetry and exporting them to Prometheus and Grafana for reporting.\n\n![Screenshot of the ASP.NET Core Grafana dashboard](~/assets/samples/Metrics/dashboard-screenshot.png)\n\n## Demonstrates\n\n- How to configure an Aspire app to export metrics to Prometheus\n- How to add Prometheus and Grafana containers to an Aspire app\n- How to configure Prometheus and Grafana to collect and display metrics in the [.NET Grafana dashboard](https://aka.ms/dotnet/grafana-source)\n\n## Sample prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- This sample is written in C# and targets .NET 10. It requires the [.NET 10.0 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later.\n\n## Running the sample\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `MetricsApp.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `Metrics.slnx` and launch/debug the `MetricsApp.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `MetricsApp.AppHost` directory.\n\n1. On the **Resources** page, click the URLsfor the instrumented app. This launches the simple .NET app.\n1. In the instrumented app:\n   1. Visit the **Weather** and **Auth Required** pages to generate metrics. Values will be captured for `http.server.request.duration` and other instruments.\n   1. On the **Home** page, click the Grafana dashboard link. This launches the ASP.NET Core dashboard in Grafana.\n1. Play around inside the Grafana dashboard:\n   1. Change the time range.\n   1. Enable auto-refresh.\n   1. Click route links to view detailed information about specific areas in the ASP.NET Core app.\n\nFor more information about using Grafana dashboards, see the [Grafana documentation](https://grafana.com/docs/grafana/latest/dashboards/use-dashboards/).\n",
    "tags": [
      "csharp",
      "dashboard",
      "grafana",
      "metrics",
      "prometheus"
    ],
    "thumbnail": "~/assets/samples/Metrics/dashboard-screenshot.png"
  },
  {
    "name": "orleans-voting",
    "title": "Aspire Orleans sample app",
    "description": "This is a simple .NET app that shows how to use Orleans with Aspire orchestration.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/orleans-voting",
    "readme": "# Aspire Orleans sample app\n\nThis is a simple .NET app that shows how to use Orleans with Aspire orchestration.\n\n## Demonstrates\n\n- How to use Aspire to work with Orleans\n\n## Sample prerequisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- This sample is written in C# and targets .NET 10. It requires the [.NET 10.0 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) or later.\n\n## Running the sample\n\nIf using the Aspire CLI, run `aspire run` from this directory.\n\nIf using VS Code, open this directory as a workspace and launch the `OrleansVoting.AppHost` project using either the Aspire or C# debuggers.\n\nIf using Visual Studio, open the solution file `OrleansVoting.slnx` and launch/debug the `OrleansVoting.AppHost` project.\n\nIf using the .NET CLI, run `dotnet run` from the `OrleansVoting.AppHost` directory.\n\n1. On the **Resources** page, click on one of the endpoints for the listed project. This launches the simple voting app.\n2. In the voting app:\n    1. Enter a poll title, some questions, and click **Create**, *or* click **DEMO: auto-fill poll** to auto-fill the poll.\n    2. On the poll page, click one of the poll options to vote for it.\n    3. The results of the poll are displayed. Click the **DEMO: simulate other voters** button to simulate other voters voting on the poll and watch the results update.\n\nFor more information about using Orleans, see the [Orleans documentation](https://learn.microsoft.com/dotnet/orleans).\n",
    "tags": [
      "csharp",
      "orleans"
    ],
    "thumbnail": null
  },
  {
    "name": "standalone-dashboard",
    "title": "Standalone Aspire dashboard sample app",
    "description": "View telemetry from any app in the Aspire dashboard. The dashboard supports running standalone, and apps configured with an [OpenTelemetry SDK](https://opentelemetry.io/docs/getting-started/dev/) can send it data.\n\nThis sample is a .NET console app that downloads data from [NuGet](https://nuget.org/). The app sends telemetry to the Aspire dashboard which is viewed in the dashboard telemetry UI.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/standalone-dashboard",
    "readme": "# Standalone Aspire dashboard sample app\n\nView telemetry from any app in the Aspire dashboard. The dashboard supports running standalone, and apps configured with an [OpenTelemetry SDK](https://opentelemetry.io/docs/getting-started/dev/) can send it data.\n\nThis sample is a .NET console app that downloads data from [NuGet](https://nuget.org/). The app sends telemetry to the Aspire dashboard which is viewed in the dashboard telemetry UI.\n\n![Screenshot of the standalone Aspire dashboard](~/assets/samples/standalone-dashboard/aspire-dashboard-screenshot.png)\n\n## Demonstrates\n\n- How to run the Aspire dashboard from a Docker container\n- How to configure a .NET app to export telemetry to the dashboard\n- How to view telemetry in the Aspire dashboard\n\n## Sample prerequisites\n\nThis sample is written in C# and targets .NET 10.0. It requires the [.NET 10.0 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later.\n\nThis sample runs the Aspire dashboard from a Docker container. It requires Docker to be installed.\n\n## Start Aspire dashboard\n\nThe following command starts the Aspire dashboard in a Docker container:\n\n``` bash\ndocker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard mcr.microsoft.com/dotnet/aspire-dashboard:latest\n```\n\nThe docker command:\n\n- Starts a container from the `mcr.microsoft.com/dotnet/nightly/aspire-dashboard` image.\n- The container has two ports:\n  - Port `4317` receives OpenTelemetry data from apps. Apps send data using [OpenTelemetry Protocol (OTLP)](https://opentelemetry.io/docs/specs/otlp/).\n  - Port `18888` has the dashboard UI. Navigate to http://localhost:18888 in the browser to view the dashboard.\n\n> [!NOTE]\n> The dashboard currently only supports the [OTLP/gRPC protocol](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc). Apps sending telemetry to the dashboard must be configured to use the `grpc` protocol. There are a couple of options for configuring apps:\n>\n> - Configure the OpenTelemetry SDK inside the app to use the gRPC OTLP protocol, or\n> - Start the app with the [`OTEL_EXPORTER_OTLP_PROTOCOL` environment variable](https://opentelemetry.io/docs/specs/otel/protocol/exporter/#configuration-options) with a value of `grpc`.\n\n## Login to the Aspire dashboard\n\nData displayed in the dashboard can be sensitive. By default, the dashboard is secured with authentication that requires a token to login.\n\nWhen the dashboard is run from a standalone container the login token is printed to the container logs. After copying the highlighted token into the login page, select the *Login* button.\n\n![Screenshot of the Aspire dashboard container logs](~/assets/samples/standalone-dashboard/aspire-dashboard-container-log.png)\n\nFor more information about logging into the dashboard, see [Dashboard authentication](https://learn.microsoft.com/dotnet/aspire/fundamentals/dashboard/explore#dashboard-authentication).\n\n## Running the sample\n\nTo download and run the sample, follow these steps:\n\n1. Clone the `dotnet/aspire-samples` repository.\n2. Navigate to the folder that holds the sample code.\n3. At the command line, type [`dotnet run ConsoleApp.cs`](https://learn.microsoft.com/dotnet/core/tools/dotnet-run).\n\nRun the .NET app by executing the following at the command prompt (opened to the base directory of the sample):\n\n``` bash\ndotnet run ConsoleApp.cs\n```\n\n1. The console app launches, downloads information about the top NuGet packages and then exits.\n2. View the Aspire dashboard at http://localhost:18888 to see app telemetry.\n    1. View structured logs to see the list of top NuGet packages.\n    2. View traces to see HTTP requests made.\n    3. View metrics to see numeric data about the app such as average HTTP request duration.\n\n## Configure OpenTelemetry\n\nThe telemetry export endpoint is configured with the `OTEL_EXPORTER_OTLP_ENDPOINT` setting. This value is set to `http://localhost:4317` in the sample's `ConsoleApp.run.json` file. Removing the `OTEL_EXPORTER_OTLP_ENDPOINT` value disables exporting telemetry.\n",
    "tags": [
      "csharp",
      "dashboard",
      "docker",
      "grpc",
      "metrics"
    ],
    "thumbnail": "~/assets/samples/standalone-dashboard/aspire-dashboard-screenshot.png"
  },
  {
    "name": "volume-mount",
    "title": "Persistent Volume",
    "description": "This sample demonstrates how to configure a SQL Server container to use a persistent volume in Aspire, so that the data is persisted across app launches. This method can be used to persist data across instances of other container types configured in Aspire apps too, e.g. PostgreSQL, Redis, etc.\n\nThe app consists of a single service, **VolumeMount.BlazorWeb**, that is configured with a SQL Server container instance via the AppHost project. PostgreSQL and Azure Storage data services are also configured in the AppHost and Blazor projects for demonstration and experimentation purposes. This Blazor Web app has been setup to use ASP.NET Core Identity for local user account registration and authentication, including [Blazor identity UI](https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/#the-blazor-identity-ui). Using a persistent volume means that user accounts created when running locally are persisted across launches of the app.\n\n\nThe app also includes a standard class library project, **VolumeMount.ServiceDefaults**, that contains the service defaults used by the service project.",
    "href": "https://github.com/dotnet/aspire-samples/tree/main/samples/volume-mount",
    "readme": "# Persistent Volume\n\nThis sample demonstrates how to configure a SQL Server container to use a persistent volume in Aspire, so that the data is persisted across app launches. This method can be used to persist data across instances of other container types configured in Aspire apps too, e.g. PostgreSQL, Redis, etc.\n\nThe app consists of a single service, **VolumeMount.BlazorWeb**, that is configured with a SQL Server container instance via the AppHost project. PostgreSQL and Azure Storage data services are also configured in the AppHost and Blazor projects for demonstration and experimentation purposes. This Blazor Web app has been setup to use ASP.NET Core Identity for local user account registration and authentication, including [Blazor identity UI](https://devblogs.microsoft.com/dotnet/whats-new-with-identity-in-dotnet-8/#the-blazor-identity-ui). Using a persistent volume means that user accounts created when running locally are persisted across launches of the app.\n\n![Screenshot of the account login page on the web front](~/assets/samples/volume-mount/volume-mount-frontend-login.png)\n\nThe app also includes a standard class library project, **VolumeMount.ServiceDefaults**, that contains the service defaults used by the service project.\n\n## Pre-requisites\n\n- [Aspire development environment](https://aspire.dev/get-started/prerequisites/)\n- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n\n## Running the app\n\n1. If using the Aspire CLI, run `aspire run` from this directory.\n\n   If using VS Code, open this directory as a workspace and launch the `VolumeMount.AppHost` project using either the Aspire or C# debuggers.\n\n   If using Visual Studio, open the solution file `VolumeMount.slnx` and launch/debug the `VolumeMount.AppHost` project.\n\n   If using the .NET CLI, run `dotnet run` from the `VolumeMount.AppHost` directory.\n\n1. Navigate to the URL for the `VolumeMount.BlazorWeb` from the dashboard.\n\n1. From the home page, click the \"Register\" link and enter a email and password to create a local user:\n\n    ![Screenshot of the account registration page on the web front end](~/assets/samples/volume-mount/volume-mount-frontend-register.png)\n\n1. After a short while (5-15s) an error page will be displayed stating that the database is not initialized and suggesting that EF Core migration be run. Click the \"Apply Migrations\" button and once the button text changes to \"Migrations Applied\", refresh the browser and confirm the form resubmission when prompted by the browser:\n\n    ![Screenshot of the database operation failed error page](~/assets/samples/volume-mount/volume-mount-frontend-dbcontext-error.png)\n\n1. A page will be shown confirming the registration of the account and a message detailing that a real email sender is not registered. Find and click the link at the end of the message to confirm the created account:\n\n    ![Screenshot of the account registration confirmation page](~/assets/samples/volume-mount/volume-mount-frontend-account-registered.png)\n\n1. Verify that the email confirmation page is displayed, indicating that the account is now registered and can be used to login to the site, and then click on the \"Login\" link in the left-hand navigation menu:\n\n    ![Screenshot of the email confirmation page](~/assets/samples/volume-mount/volume-mount-frontend-email-confirmed.png)\n\n1. Enter the email and password you used in the account registration page to login:\n\n    ![Screenshot of the login page](~/assets/samples/volume-mount/volume-mount-frontend-login.png)\n\n1. Once logged in, click the \"Logout\" link in the left-hand navigation menu to log out of the site, and then stop the app, followed by starting it again, and verifying that the account you just created can still be used to login to the site once restarted, indicating that the database was using the persistent volume to store the data. You can verify the named volume existance using the Docker CLI too (`docker volume ls`):\n\n    ```shell\n    > docker volume ls -f name=sqlserver\n    DRIVER    VOLUME NAME\n    local     volumemount.apphost-305a028ab1-sqlserver-data\n    ```\n",
    "tags": [
      "azure",
      "azure-storage",
      "blazor",
      "csharp",
      "dashboard",
      "databases",
      "docker",
      "ef-core",
      "migrations",
      "postgresql",
      "redis",
      "sql-server",
      "volumes"
    ],
    "thumbnail": "~/assets/samples/volume-mount/volume-mount-frontend-login.png"
  }
]